<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Particle Constellation</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body, html {
      width: 100%;
      height: 100%;
      overflow: hidden;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
    }

    #particleCanvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, #0a0a0f 0%, #1a1a2e 100%);
      display: block;
    }
  </style>
</head>
<body>
  <canvas id="particleCanvas"></canvas>

  <script>
    // Configuration
    const config = {
      particleCount: window.innerWidth < 768 ? 60 : 120,
      maxDistance: 150,
      mouseRadius: 180,
      baseSpeed: 0.3,
      colors: [
        { r: 139, g: 92, b: 246, name: 'purple' },
        { r: 59, g: 130, b: 246, name: 'blue' },
        { r: 236, g: 72, b: 153, name: 'pink' }
      ]
    };

    // Mouse tracking
    const mouse = { x: null, y: null };

    // Particle Class
    class Particle {
      constructor(canvas) {
        this.canvas = canvas;
        this.colorIndex = Math.floor(Math.random() * config.colors.length);
        this.baseSize = Math.random() * 2 + 1;
        this.pulsePhase = Math.random() * Math.PI * 2;
        this.pulseSpeed = 0.02 + Math.random() * 0.02;
        this.magnetism = 0.1 + Math.random() * 0.4;
        this.reset(true);
      }

      reset(initial = false) {
        this.x = initial ? Math.random() * this.canvas.width : this.x;
        this.y = initial ? Math.random() * this.canvas.height : this.y;
        this.vx = (Math.random() - 0.5) * config.baseSpeed;
        this.vy = (Math.random() - 0.5) * config.baseSpeed;
      }

      update() {
        // Mouse attraction
        if (mouse.x !== null) {
          const dx = mouse.x - this.x;
          const dy = mouse.y - this.y;
          const distSq = dx * dx + dy * dy;
          const mouseRadiusSq = config.mouseRadius * config.mouseRadius;

          if (distSq < mouseRadiusSq) {
            const dist = Math.sqrt(distSq);
            const force = (1 - dist / config.mouseRadius) * this.magnetism;
            this.vx += (dx / dist) * force * 0.5;
            this.vy += (dy / dist) * force * 0.5;
          }
        }

        // Apply velocity
        this.x += this.vx;
        this.y += this.vy;

        // Friction
        this.vx *= 0.99;
        this.vy *= 0.99;

        // Subtle random movement
        this.vx += (Math.random() - 0.5) * 0.05;
        this.vy += (Math.random() - 0.5) * 0.05;

        // Speed limit
        const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
        if (speed > 2) {
          this.vx = (this.vx / speed) * 2;
          this.vy = (this.vy / speed) * 2;
        }

        // Bounce off edges with padding
        const padding = 50;
        if (this.x < -padding || this.x > this.canvas.width + padding) {
          this.vx *= -1;
          this.x = Math.max(-padding, Math.min(this.canvas.width + padding, this.x));
        }
        if (this.y < -padding || this.y > this.canvas.height + padding) {
          this.vy *= -1;
          this.y = Math.max(-padding, Math.min(this.canvas.height + padding, this.y));
        }

        // Pulse animation
        this.pulsePhase += this.pulseSpeed;
      }

      draw(ctx) {
        const color = config.colors[this.colorIndex];
        const pulse = Math.sin(this.pulsePhase) * 0.3 + 0.7;
        const size = this.baseSize * pulse;

        // Glow effect
        const gradient = ctx.createRadialGradient(
          this.x, this.y, 0,
          this.x, this.y, size * 4
        );
        gradient.addColorStop(0, `rgba(${color.r}, ${color.g}, ${color.b}, 0.8)`);
        gradient.addColorStop(0.4, `rgba(${color.r}, ${color.g}, ${color.b}, 0.4)`);
        gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');

        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(this.x, this.y, size * 4, 0, Math.PI * 2);
        ctx.fill();

        // Core particle
        ctx.fillStyle = `rgba(${color.r}, ${color.g}, ${color.b}, 1)`;
        ctx.beginPath();
        ctx.arc(this.x, this.y, size, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    // Initialize Canvas
    const canvas = document.getElementById('particleCanvas');
    const ctx = canvas.getContext('2d', { 
      alpha: true,
      desynchronized: true 
    });
    const ratio = window.devicePixelRatio || 1;
    let particles = [];
    let animationId;

    function resizeCanvas() {
      canvas.width = window.innerWidth * ratio;
      canvas.height = window.innerHeight * ratio;
      canvas.style.width = window.innerWidth + 'px';
      canvas.style.height = window.innerHeight + 'px';
      ctx.scale(ratio, ratio);
      initParticles();
    }

    function initParticles() {
      particles = [];
      for (let i = 0; i < config.particleCount; i++) {
        particles.push(new Particle(canvas));
      }
    }

    function drawConnections() {
      const maxDistSq = config.maxDistance * config.maxDistance;

      for (let i = 0; i < particles.length; i++) {
        for (let j = i + 1; j < particles.length; j++) {
          const dx = particles[i].x - particles[j].x;
          const dy = particles[i].y - particles[j].y;
          const distSq = dx * dx + dy * dy;

          if (distSq < maxDistSq) {
            const dist = Math.sqrt(distSq);
            const opacity = (1 - dist / config.maxDistance) * 0.5;

            // Blend colors
            const color1 = config.colors[particles[i].colorIndex];
            const color2 = config.colors[particles[j].colorIndex];
            const r = Math.round((color1.r + color2.r) / 2);
            const g = Math.round((color1.g + color2.g) / 2);
            const b = Math.round((color1.b + color2.b) / 2);

            // Mouse proximity boost
            let mouseBoost = 0;
            if (mouse.x !== null) {
              const midX = (particles[i].x + particles[j].x) / 2;
              const midY = (particles[i].y + particles[j].y) / 2;
              const mdx = mouse.x - midX;
              const mdy = mouse.y - midY;
              const mouseDist = Math.sqrt(mdx * mdx + mdy * mdy);
              
              if (mouseDist < config.mouseRadius) {
                mouseBoost = (1 - mouseDist / config.mouseRadius) * 0.4;
              }
            }

            const finalOpacity = Math.min(opacity + mouseBoost, 0.8);
            const lineWidth = 0.5 + mouseBoost * 2;

            ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${finalOpacity})`;
            ctx.lineWidth = lineWidth;
            ctx.beginPath();
            ctx.moveTo(particles[i].x, particles[i].y);
            ctx.lineTo(particles[j].x, particles[j].y);
            ctx.stroke();
          }
        }
      }
    }

    function render() {
      // Clear with trail effect
      ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Update particles
      particles.forEach(particle => particle.update());

      // Draw connections
      drawConnections();

      // Draw particles
      particles.forEach(particle => particle.draw(ctx));

      animationId = requestAnimationFrame(render);
    }

    // Event Listeners
    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      mouse.x = e.clientX - rect.left;
      mouse.y = e.clientY - rect.top;
    });

    canvas.addEventListener('mouseleave', () => {
      mouse.x = null;
      mouse.y = null;
    });

    canvas.addEventListener('touchmove', (e) => {
      const rect = canvas.getBoundingClientRect();
      const touch = e.touches[0];
      mouse.x = touch.clientX - rect.left;
      mouse.y = touch.clientY - rect.top;
    });

    canvas.addEventListener('touchend', () => {
      mouse.x = null;
      mouse.y = null;
    });

    window.addEventListener('resize', resizeCanvas);

    // Start animation
    resizeCanvas();
    render();
  </script>
</body>
</html>
